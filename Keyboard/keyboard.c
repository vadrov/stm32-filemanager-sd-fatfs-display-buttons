/* ------------------------------------------------------------------------------------/
 /     Модуль для работы с кнопоками на микроконтроллере stm32f4 (и не только).
 * ------------------------------------------------------------------------------------/
 *
 *  Автор: VadRov
 *  Copyright (C) 2021, VadRov, all right reserved.
 *
 *  Допускается свободное распространение без целей коммерческого использования.
 *  При коммерческом использовании необходимо согласование с автором.
 *  Распространятся по типу "как есть", то есть использование осуществляете на свой страх и риск.
 *  Автор не предоставляет никаких гарантий.
 *
 *  Возможности модуля:
 *  - Поддержка до 32 кнопок, с учетом того, что на 1 кнопку выделяется 1 вывод микроконтроллера,
 *  настроенный на вход с подтяжкой по питанию.
 *  - Доступна настройка фильтра устранения дребезга.
 *  - Доступен буфер состояний кнопок с настраиваемой глубиной.
 *  - Доступна настройка периодов задержки до первого автоповтора нажатия кнопок и последующих автоповторов.
 *  - Доступно добавление кнопок для опроса посредством вызова соответствующей функции.
 *  - Доступна установка статусов кнопки: "активна" - участвует в опросе, "пассивна" - не участвует в опросе.
 *  - Доступен опрос статуса кнопки (активна либо пассивна).
 *
 *  Выводы микроконтроллера, к которым подключаются кнопки должны быть настроены, как входы с подтяжкой по питанию. Как вариант, с использованием
 *	внутренней подтяжки микроконтроллера pull-up, либо внешней через подтягивающий резистор, например, номиналом 10 кОм.
 *	При нажатии кнопки должна осуществляется притяжка входа к "земле" (GND).
 *
 *	Для работы библиотеки требуется 1 таймер с настроенным прерыванием по обновлению.
 *	В функцию обработки прерывания таймера (например, в файле stm32f4xx_it.c) необходимо включить cтроку:
 *	KEYB_Input_Keys(); //вызов процедуры опроса кнопок
 *	В файле вызова KEYB_Input_Keys() необходимо определить прототип функции: extern void KEYB_Input_Keys(void)
 *	или подключить заголовочный файл keyboard.h: #include "keyboard.h"
 *	Да, и не забудьте в своей программе разрешить прерывания по обновлению таймера и включить таймер.
 *	Например, вот так для stm32f4:
 *	KEYB_TIM->DIER |= TIM_DIER_UIE;
	KEYB_TIM->CR1  |= TIM_CR1_CEN;
 *  где KEYB_TIM - номер таймера, определяемый в файле keyboard.h
 *
 *	Свои кнопки для опроса добавляем с использованием функции
 *	KEYB_Add_Button(key_port, key_pin, key_bit, key_status);
 *	где:  key_port   - указатель на используемый порт кнопки, например, GPIOA (порт А);
 *		  key_pin    - используемый пин порта кнопки, например, LL_GPIO_PIN_3 (3 пин);
 *		  key_bit    - номер бита, соответствующий кнопке в переменной состояний кнопок, например, 0 (0 бит)
 *		  key_status - статус кнопки: активная (KEYB_BUTTON_ACTIVE) либо пассивная (KEYB_BUTTON_PASSIVE),
 *		               активная опрашивается, а пассивная - нет.
 *
 *  Текущее состояние кнопок (из буфера) получаем путем вызова функции KEYB_Inkeys(), которая в 32-разрядной переменной
 *  возвращает, т.н., "битовое поле", в котором каждой кнопке соответствует бит, номер которого является номером бита
 *  заданным для кнопки в "Описании кнопок". Установленный бит - кнопка нажата, сброшенный - не нажата.
 *
 *  Статус кнопок (активная/пассивная) можно менять путем вызова функции KEYB_Set_Button_Status(key_bit, key_status),
 *  передав номер бита кнопки из описания и желаемый статус.
 *
 *  Статус кнопки (активная/пассивная) можно получить путем вызова функции KEYB_Get_Button_Status(key_bit),
 *  передав номер бита кнопки из описания.
 *
 *  Модуль легко редактируется для использования с любым микроконтроллером (не только stm32).
 *
 *  Все настройки модуля определены в файле keyboard.h
 *
 *  https://www.youtube.com/@VadRov
 *  https://dzen.ru/vadrov
 *  https://vk.com/vadrov
 *  https://t.me/vadrov_channel
 *
 */

#include "keyboard.h"
#include "stdlib.h"

uint32_t KEYB_old_keys = 0;						//Предыдущее состояние клавиш (установленный бит - нажата соответствующая клавиша).
												//Размерность переменной в 32 бита позволяет хранить информацию о состоянии 32 кнопок

uint32_t KEYB_repeat_pre_count = 0; 			//Счетчик для первого автоповтора
uint8_t  KEYB_repeat_fl = 0;					//Флаг автоповтора
uint32_t KEYB_repeat_count = 0; 				//Счетчик автоповтора
uint8_t  KEYB_contact_counter = 0;  			//Счетчик устранения дребезга
uint32_t KEYB_key_buff[KEYB_SIZE_BUFFER] = {0}; //Буфер хранения состояний кнопок.
										   	    //Позволяет хранить KEYB_SIZE_BUFFER предыдущих состояний кнопок для
										   	    //организации, т.н., буферизованного ввода
uint8_t  KEYB_count_key = 0;					//Счетчик-позиция в буфере состояний кнопок
uint8_t  KEYB_all_button = 0;					//Счетчик количества кнопок
KEYB_key_map_ *KEYB_keys_map = 0;				//Указатель на массив с данными кнопок

//функция добавляет кнопку
void KEYB_Add_Button(GPIO_TypeDef *key_port, uint32_t key_pin, uint8_t key_bit, KEYB_BUTTON_STATUS key_status)
{
	KEYB_all_button++;
	KEYB_keys_map = (KEYB_key_map_*)realloc(KEYB_keys_map, KEYB_all_button*sizeof(KEYB_key_map_));
	KEYB_key_map_ *button = &KEYB_keys_map[KEYB_all_button-1];
	button->key_port = key_port;
	button->key_pin = key_pin;
	button->key_bit = key_bit;
	button->key_status = key_status;
}

//Функция возвращает статус кнопки
KEYB_BUTTON_STATUS KEYB_Get_Button_Status(uint8_t key_bit)
{
	uint8_t i = KEYB_all_button;
	KEYB_BUTTON_STATUS stat = KEYB_BUTTON_UNKNOW;
	while(i)
	{
		if (KEYB_keys_map[KEYB_all_button - i].key_bit == key_bit)
		{
			stat = KEYB_keys_map[KEYB_all_button - i].key_status;
			break;
		}
		i--;
	}
	return stat;
}

//Функция устанавливает статус кнопки
void KEYB_Set_Button_Status(uint8_t key_bit, KEYB_BUTTON_STATUS key_status)
{
	uint8_t i = KEYB_all_button;
	while(i)
	{
		if (KEYB_keys_map[KEYB_all_button - i].key_bit == key_bit)
		{
			KEYB_keys_map[KEYB_all_button - i].key_status = key_status;
			return;
		}
		i--;
	}
}

//функция возвращает битовое поле клавиш из текушей позиции буфера ввода
//Используется в пользовательской программе для реализации опроса кнопок.
//Для того, чтобы узнать нажата кнопка или нет, необходимо опросить соответствующий
//ей бит в возвращенном значении.
//Кнопки для опроса добавляются функцией KEYB_Add_Button.
uint32_t KEYB_Inkeys(void)
{
	uint32_t k_inkey = 0;
	//есть ли в буфере данные и определена ли хотя бы одна кнопка?
	KEYB_TIM->DIER &= ~TIM_DIER_UIE;
	if (KEYB_count_key && KEYB_all_button)
	{
		//читаем данные из 0 позиции буфера
		k_inkey = KEYB_key_buff[0];
		//смещаем буфер на 1 позицию влево
		for (int i = 0; i < KEYB_SIZE_BUFFER - 1; i++)
		{
			KEYB_key_buff[i] = KEYB_key_buff[i + 1];
		}
		//уменьшаем количество данных в буфере на 1
		KEYB_count_key--;
		//дописываем 0
		KEYB_key_buff[KEYB_SIZE_BUFFER - 1] = 0;
	}
	KEYB_TIM->DIER |= TIM_DIER_UIE;
	return k_inkey;
}

//Функция возвращает 1, если нажата какая-либо кнопка. В противном случае возвращает 0.
//В любом случае состояние кнопок не удаляется из входного буфера
uint8_t KEYB_kbhit(void)
{
	//есть ли в буфере данные и определена ли хотя бы одна кнопка?
	if (KEYB_count_key && KEYB_all_button)	{
		return 1;
	}
	return 0;
}


//опрос кнопок
void KEYB_Input_Keys(void)
{
	KEYB_TIM->SR &= ~TIM_SR_UIF; //сброс флага прерывания по обновлению
	uint32_t keys = 0;//переменная для хранения состояний кнопок
	int i = 0;
	KEYB_key_map_ *button; //хранит указатель на данные (порт, пин, бит) текущей кнопки
	if (!KEYB_all_button) return; //если нет ни одной добавленной кнопки, то выходим
	while(i < KEYB_all_button) //в цикле читаем состояние всех кнопок, параметры которых заданы в массиве KEYB_keys_map
	{
		button = &KEYB_keys_map[i++]; //указатель на данные текущей кнопки
		if (button->key_status != KEYB_BUTTON_ACTIVE) continue; //если кнопка неактивна (неиспользуется), то пропускаем ее
		//Кнопка нажата, если состояние входа равно 0 (вход прижат к "земле"). При выполнении этого условия устанавливаем бит,
		//соответствующий кнопке в переменной keys.
		if (!(button->key_port->IDR & button->key_pin)) keys |= 1<<button->key_bit;
	}
	if (keys && (KEYB_old_keys == keys)) //предыдущая кнопка/комбинация равна текущей?
	{
		KEYB_contact_counter++; //увеличиваем счетчик фильтра дребезга
		if (KEYB_contact_counter < KEYB_CONTACT_PER) return; //прошло ли время для устранения дребезга?
		if (KEYB_repeat_fl) //установлен ли флаг автоповтора?
		{
			KEYB_contact_counter = KEYB_CONTACT_PER;
			KEYB_repeat_count++; //увеличиваем счетчик автоповтора
			if (KEYB_repeat_count < KEYB_REPEAT_PER) return; //прошло ли время включения автоповтора?
			KEYB_repeat_count = 0; //инициализируем счетчик автоповтора
		}
		else
		{
			if (!KEYB_repeat_pre_count) //это первый автоповтор?
			{
				//запоминаем в буфере состояние кнопок
				if (KEYB_count_key < KEYB_SIZE_BUFFER) //есть ли место в буфере ввода?
				{
					KEYB_key_buff[KEYB_count_key] = keys; //запоминаем состояние кнопок в буфере
					KEYB_count_key++; //увеличиваем счетчик запомненных состояний кнопок
				}
			}
			KEYB_repeat_pre_count++; //увеличиваем счетчик-задержку до первого автоповтора
			if (KEYB_repeat_pre_count < KEYB_REPPRE_PER) return; //
			KEYB_repeat_pre_count = 0; //инициализируем счетчик-задержку до первого автоповтора
			KEYB_repeat_fl = 1; //устанавливаем флаг автоповтора
			KEYB_repeat_count = 0; //инициализируем счетчик автоповтора
			KEYB_contact_counter = KEYB_CONTACT_PER;
			return;
		}
		if (KEYB_count_key < KEYB_SIZE_BUFFER) //есть ли место в буфере ввода?
		{
			KEYB_key_buff[KEYB_count_key] = keys; //запоминаем состояние кнопок в буфере
			KEYB_count_key++; //увеличиваем счетчик запомненных в буфере состояний кнопок
		}
		return;
	}
	//текущая кнопка/комбинация отличается от предыдущей
	KEYB_old_keys = keys; //старая кобинация = текущей
	KEYB_contact_counter = 0; //инициализация счетчика устранения дребезга
	KEYB_repeat_fl = 0; //сброс флага автоповтора
	KEYB_repeat_count = 0; //инициализация счетчика автоповтора
	KEYB_repeat_pre_count = 0; //инициализация счетчика-задержки до первого автоповтора
}
